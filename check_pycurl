#!/usr/bin/env python

# check_pycurl ; -*-Python-*-
# Copyright James Powell 2013 / jamespo [at] gmail [dot] com
# This program is distributed under the terms of the GNU General Public License v3

import pycurl
import cStringIO
import uuid
import sys
import re
import yaml
from optparse import OptionParser

class CheckPyCurlOptions(object):
    '''class to contain check options for multi-mode'''
    def __init__(self):
        # set defaults if not present (TODO: set these in one place)
        self.test = 'code:200'
        self.connecttimeout = 5
        self.timeout = 10
        self.location = False
        self.insecure = False
        self.proxy = ''


class CheckPyCurlMulti(object):
    def __init__(self, runfile):
        self.runfile = runfile
        self.checkobjs = []

    @staticmethod
    def tmpfile():
        '''return temporary filename'''
        return "%s%s" % ('/tmp/check_pycurl_', str(uuid.uuid4()))

    def parse_runfile(self):
        '''parse runfile & create check objects'''
        with open(self.runfile) as f:
            runyaml = yaml.load(f)
            # print runyaml
        # set global prefs
        cookie = False
        if 'cookiejar' in runyaml:
            if runyaml['cookiejar'] != 'no': cookie = True
            CheckPyCurlOptions.tmpfile = self.tmpfile()
        setattr(CheckPyCurlOptions, 'cookiejar', cookie)
        # loop round urls in object & create checkobjects
        for url in runyaml['urls']:
            check_opt = CheckPyCurlOptions()
            for opt in url:
                setattr(check_opt, opt, url[opt])
            self.checkobjs.append(check_opt)

    def check_runfile(self):
        '''run check objects'''
        cpc = None
        for (counter, checkobj) in enumerate(self.checkobjs):
            cpc = CheckPyCurl(checkobj)
            rc = cpc.curl()
            cpc.results['stage'] = counter
            if rc != 0:
                return cpc
        return cpc

class CheckPyCurl(object):
    def __init__(self, options):
        self.options = options
        self.results = dict()
        [self.successtest, self.successcheck] = options.test.split(':')

    def curl(self):
        buf = cStringIO.StringIO()
        c = pycurl.Curl()
        c.setopt(c.URL, self.options.url)
        c.setopt(c.CONNECTTIMEOUT, self.options.connecttimeout)
        c.setopt(c.TIMEOUT, self.options.timeout)
        c.setopt(c.FOLLOWLOCATION, self.options.location)
        c.setopt(c.SSL_VERIFYPEER, self.options.insecure)
        if getattr(self.options, 'cookiejar', None) is not None:
            print self.options.tmpfile
        if self.options.proxy is not None:
            c.setopt(c.PROXY, self.options.proxy)
        c.setopt(c.WRITEFUNCTION, buf.write)
        try:
            c.perform()
            self.results['rc'] = 0
            self.results['status'] = "%s returned HTTP %s" % (self.options.url,
                                      c.getinfo(pycurl.HTTP_CODE))
            # check results
            if self.successtest == 'code':
                if int(self.successcheck) != int(c.getinfo(pycurl.HTTP_CODE)):
                    self.results['rc'] = 2
            elif self.successtest == 'regex':
                if re.search(self.successcheck, self.content) is not None:
                    self.results['status'] = "%s found in %s" % (self.successcheck,
                                         self.options.url)
                    self.results['rc'] = 0
                else:
                    self.results['status'] = "%s not found in %s" % (self.successcheck,
                                             self.options.url)
                    self.results['rc'] = 2
            else:
                self.results['rc'] = 1
        except pycurl.error, excep:
            self.results['rc'] = 2
            self.results['status'] = excep[1]

        #self.content = buf.getvalue()
        buf.close()

        self.results['totaltime'] = c.getinfo(pycurl.TOTAL_TIME)
        return self.results['rc']

def checkargs(options):
    if options.url is None and options.runfile is None:
        # 3 is return code for unknown for NRPE plugin
        return (3, 'No URL / runfile supplied')
    # TODO: check if runfile exists
    else:
        return (0, '')

def main():
    parser = OptionParser()
    parser.add_option("-u", "--url", dest="url")
    parser.add_option("-f", "--runfile", dest="runfile")
    parser.add_option("--test", dest="test",
              default="code:200", help="[code:HTTPCODE|regex:REGEX]")
    parser.add_option("--connect-timeout", dest="connecttimeout",
              default=5)
    parser.add_option("--timeout", dest="timeout",
              default=10)
    parser.add_option("--proxy", dest="proxy")
    parser.add_option("--location", help="Follow redirects",
              dest="location", action="store_true", default=False)
    parser.add_option("--insecure", dest="insecure", action="store_true",
              default=False)
    (options, args) = parser.parse_args()
    (rc, rcstr) = checkargs(options)

    if rc != 3:
        if options.url is not None:
            cpc = CheckPyCurl(options)
            rc = cpc.curl()
            rcstr = 'OK:' if rc == 0 else 'CRITICAL:'
            rcstr = rcstr + ' ' + cpc.results['status']
        else:
            # runfile
            a = CheckPyCurlMulti(options.runfile)
            a.parse_runfile()
            cpc = a.check_runfile()
            rc = cpc.results['rc']
            if rc == 0:
                rcstr = 'OK: All stages passed'
            else:
                rcstr = 'CRITICAL: Stage %s - %s (should be %s)' % \
                (cpc.results['stage'], cpc.results['status'], cpc.options.test)
    print rcstr
    sys.exit(rc)

if __name__ == '__main__':
    main()

